# Solution for auto-generating forms and their associated schema

Inspired from the core principles of [Netlify Cms](https://www.netlifycms.org/), this system was built and adapted to better fit this project specificity.

The following documentation will attempt to explain how forms and schema pages can be auto-generated by using a single `.yml` file, in concordance with the form and schema layouts as well as the translation documents in the `_data/i18n/` folder. However, there are still some limits to the automation process, and the javascript will still need to be manually created.

This document describes how each solution element works. Instructions on how to use, update and create solution elements are also presented.

## Pages

Found under the `_pages/` folder, pages must follow the template below so that all the data that you will set up next can be used.

**WARNING** When creating or updating pages, make sure that changes are applied to both languages! Find the corresponding pages in `_pages/en` and `_pages/fr`. Look for pages that have the same `ref` value in their header.

In general, pages have the header variables presented below. These header variables must be included in any form_or_schema page (an example is provided at the end of the list).

- `layout`: defines which layout structure to follow. Its default value is "default". Layouts are defined in the `_layouts/` folder.
- `ref`: defines the page's ID, which is unique between different pages. However, a french page must have the same `ref` value as its corresponding english page and vice versa, allowing the website to redirect to the proper page when switching between languages, as pages might not have the same name in both languages.
- `lang`: defines the associated language of the page. Used mostly as `[page.lang]` throughout the templates, it selects the correct value for a translation. The accepted values are either `en` or `fr` (case is important).
- `permalink`: The permalink for the page (at least the part that will be appended to the base URL of the website). It overrides the file location in the folders when the website is compiled. Follow the convention `/[lang]/[page_name].html`.

### Header example for a standard page

```yaml
---
layout: default
ref: example
lang: en
permalink: /en/example.html
---
```

### Form page

Form pages require a few adjustments:

- `layout`: form pages use "form" as their layout value instead of "default".
- `config`: refers to the name of the Yaml config file in `_data/forms/` associated with the current form. That's how the relation is created between the current layout and the required data for the form.

#### Header example for a form page

```yaml
---
layout: form
ref: exampleForm
lang: en
permalink: /en/example-form.html
config: config-example  # Will fetch _data/forms/config-example.yml
---
```

### Schema page

Schema pages use the same parameters as form pages, but the `layout` variable must be set to "schema". In addition, the schema and form pages that are associated to one another must have the same `config` value. That way, both pages can pull from the same data.

#### Header example for a schema page

```yaml
---
layout: schema
ref: exampleSchema
lang: en
permalink: /en/example-schema.html
config: config-example
---
```

## Layouts

Forms and schema pages pull from the same two layouts that act as templates in which data (extracted from the config files) will be added.

### Form layout

Found under `_layouts/form.html`, it inherits from the default layout in order to include the header, footer and other fixed components of the website.

#### How it works

First, using `{{ page.content }}`, the content defined in the page that use this layout is added. The aim is to include all page-specific contents you wish to add.

Then comes the *form tag* which includes:

- the classes and IDs which are required for the form validation plugin (that comes with the [WET-BOEW](https://wet-boew.github.io/wet-boew/docs/ref/formvalid/formvalid-en.html) template)
- the `idPresets` definition. This variable refers to the first-level group "presets" in the translation file.
- an `include` call to the form loop (`loop.html`), allowing the template system to look for the values in the config file and to include the right elements to the form
- an `include` call to the submitter file. Contact information of the person submitting the form (name and email address) are required for the creation of the pull requests. Since we're currently using an anonymous bot to create all pull requests, the information requested allow to keep track of who submitted the changes.
- the submit and reset buttons. Note that the submit button has a unique id corresponding to `prbotSubmit{{ page.ref }}` where `{{ page.ref }}` refers to the value of `ref` in the page header. This will come up later in the JavaScript files, when binding the submit event to the button. It was added to better distinguish between the different submit function calls and to prevent errors. Various alerts are then added, improving the user experience.

All these elements are located in the layout instead of the page or config file since they should appear in all form pages, regardless which form the page is referring to.

### Schema layout

Found under `_layouts/schema.html`, it inherits from the default layout in order to include the header, footer and other fixed components of the website.

#### How it works

First, using `{{ page.content }}`, the content defined in the page using this layout is added. The aim is to include all page-specific contents you wish to add. Finally, a similar loop to the form's layout is included to the schema page.

## Config files

The config files are the backbone of the solution. They specify each component that should be included in the form and schema, as well as its parameters.

**Here's an example file:**

Note that the list of available presets and widgets, as well as their parameters, are presented later on, in their corresponding sections.

```yaml
---

id: example

formGroups:
  - preset: aPreset
  - widget: aWidget
    title: myTitle
    param: {myParam: myValue}

```

### Presets

Found under `_includes/[form_or_schema]/presets/`, presets are a set of (mostly) static sections that rarely take in parameters and should be used as is. Preset are created in one of the following situations:

- when a section is called from two or more forms, as it made more sense to have it predefined instead of having to specify the same parameters twice
- when the section is too specific or doesn't fit in any of the widgets, either because it has some minor changes that would have been too specific to add as a parameter, or because the format is completely different from any widget

The following sections explain each of the available presets:

- adminCode
- category
- contact
- description
- empty (*schema only*)
- homepageURL
- hr
- languages
- licenses
- name (*form only*)
- partners
- relatedCode
- selectCode, selectPartnership, selectSoftware, and selectStandard
- status
- submitter
- tags
- team

The parameters for the presets are located in a separate file in `_data/forms/[preset_name].yml`.

#### adminCode

The adminCode preset displays a `<select>` widget for administrations, which are separated into groups for each level of government (federal, provincial, municipal, aboriginal, etc.). You can check the list of administrations in `_data/administrations/[level_of_gov.].yml`.

The select widget is followed by a button, allowing the user to create a new administration in case his administration was not already in that list. The button opens a new section in the form, containing the required fields for the creation of a new administration. For more information on these fields, consult the **newAdmin** preset section.

When selecting the appropriate administration (depending on the type of the form), JavaScript should be added to auto-fill the administration section of the form. This follows the same logic as for the **selectCode**, **selectPartnership**, **selectSoftware**, and **selectStandard** presets.

This preset takes no additional parameters.

```yaml
  - preset: adminCode
```

#### category

The category preset display a `<select>` element with the different categories corresponding to the Family of the UNSPSC Taxonomy codes. The values for the options are located in `_data/i18n/categories.yml`.

This preset takes no additional parameters

```yaml
  - preset: category
```

#### contact

The contact preset displays a group of fields (name and email address) of the person or organization to contact for general inquiries regarding the open source project.

This preset takes one *optional* parameter:

- `phone`: specifies if the phone field should be added or not. Its default value is `false`.

```yaml
  - preset: contact
    phone: true  # bool
```

#### description

The description preset displays two categories (What it does, How it works) each having one field for each languages. This preset was created since all the forms made use of a description field.

This preset takes no additional parameters.

```yaml
  - preset: description
```

#### empty (*schema only*)

The empty preset does not display anything in the form, but rather serves only as an [array] wrapper in the schema when there is a list of elements that are only updated as individual elements in the form. For instance, for the "release" array of the code schema (`_data/schemaCode.yaml`), it makes no sense to change the layout of the form to adapt to an array since only one release can be updated at a time. However, this should still be displayed as an array in the schema page.

This preset takes two **required** parameters:

- `start` defines whether it is the start or the end of the array element in the schema (decides to add either the beginning or the ending html markup). Default value is `false`.
- `title` defines the name of the array element in the schema (also used for the translations, see the widget section for more information about title parameters)

```yaml
  - preset: empty
    start: true  # bool
    title: example
# Beginning a group / array
```

OR

```yaml
  - preset: empty
# Closing a group / array
```

#### homepageUrl

The homepageUrl preset displays a duo of fields, one for the english and the other for the french homepage URL of the current project. This preset was created since at least two of the forms made use of a homepage URL.

This preset takes no additional parameters.

```yaml
  - preset: homepageUrl
```

#### hr (*form only*)

The hr preset is a simple `<hr>` tag, but was created to specify sections in which the fields could be auto-completed when using a select input. For instance, in the Open Source Software form, selecting an already existing project would fill its information, leaving the user to fill only the remaining part of selecting their administration and updating its uses.

This preset takes no additional parameters.

```yaml
  - preset: hr
```

This preset does not appear in the schema. And even if there is a file for it in the schema folder, that file is empty. It was only added so the loop wouldn't throw an error since we're using the same config file for both the form and the schema page.

#### Languages

The languages preset displays a list of check boxes, allowing the user to select programming languages associated to the current project. It also allows the user to add other programming languages that are not listed. This preset was created since its html markup differed from the other components and widgets.

This preset takes no additional parameters.

```yaml
  - preset: languages
```

#### Licenses

The licenses preset displays two fields for the license URLs (for english and french URLs) and a field for the spdxID of the license. The label for the spdxID contains a link to a list and definition of spdxIDs.

This preset takes no additional parameters.

```yaml
  - preset: licenses
```

#### partners

The partners preset is one of the more complicated presets. It also has a lot of JavaScript associated with it. It allows a user to create a new administration or select an existing one to add as a partner for the project as well as adding specific contact informations for the administration.

This preset takes no additional parameters.

```yaml
  - preset: partners
```

#### relatedCode

The relatedCode preset displays four fields:

- The URLs (english and french) of the related code
- The Names (english and french) of the related code

This preset takes no additional parameters.

```yaml
  - preset: relatedCode
```

#### selectCode, selectDesign, selectPartnership, selectSoftware and selectStandard

The selectCode, as well as the selectDesign, the selectPartnership, the selectSoftware and the selectStandard presets display a `<select>` widget allowing the user to select an already existing project in order to edit it or add a new linked element (releases, uses, administrations, etc.). The whole point of these presets are to auto-fill the corresponding section of the form when selecting an existing project.

In the schema, these usually display only the project name fields (english and french).

This follows a similar principle as the **adminCode** preset.

These presets take no additional parameters.

```yaml
  - preset: selectCode
```

#### status

The status preset displays a `<select>` input with the possible project status (Alpha, Beta, Maintained, Deprecated or Retired). It was created since at least two or more form used it.

This preset takes no additional parameters.

```yaml
  - preset: status
```

#### submitter

The submitter preset displays a separated section of the form asking for the user contact information (name, email address), in order to keep track of who submitted the form.

The submitter preset shouldn't be added in the config files since it's already included in the form layout. See the section about the form layout for more information.

#### tags

The tags preset displays fields for adding tags to the current project. There are sections for both english and french tags, as well as a button to add more tags, other than the first required one.

This preset takes one *optional* parameters.

```yaml
  - preset: tags
    param: {required: false}  # defaults to true
```

### Creating a new preset

The steps to creating a new preset are presented below. But first, check whether this new preset is really necessary. As explained in the presets description, they should be created only when a certain form component appears in more than one form or when a certain form component does not follow the simple markup of any other widget. However, for the new structure or markup that appears more than once, creating a more generic widget instead might also be beneficial, and hence, more reflection is necessary to make the best decision.

#### Add your new preset in the form components

Under `_includes/form/presets/`, create a file for your new preset. Its name should follow the camelCase convention. Fill it with html markup. Inspiration from other presets can help. Don't be afraid to simply include widgets in it using specific parameters, that's how most presets work when they are used in more than one form.

```yaml
  - preset: example
    param: {test: myValue}
```

The value for `test` can then be accessed in your preset as `include.param.test`. In fact, include is the keyword used to access parameters declared in any file under the `_includes/` folder.

#### Add your new preset in the schema components

Under `_includes/schema/presets/`, create a file for your new preset. Its name should match the one in the form folder. To fill it, follow the same advice as for the form.

### Widgets

Found under `_includes/[form_or_schema]/widgets/`, widgets are generic components that take more parameters and thus can be configured to fit different sections of a form.

Example: Widget

```yaml
  - widget: example  # enum()
    title: ~
    param: {myParam: myvalue}
```

#### Parameters and default values:

The following example displays the list of all parameters and their default values

- `~` indicates that there is no default values
- `enum` indicates that there is a fixed list available values.

```yaml
  - widget: myWidget
    title: myTitle
    param: {
      required: true,
      type: ~,  #enum
      rule: ~,  #enum
      more: false
    }
```

In this example,

- `widget`: specifies which widget to include. This parameter is **required**, otherwise the form will display an error message.
- `title`: the title of the widget. Must be unique for every widget (exception applies for some available widgets). This parameter is **required**, otherwise the widget won't display any text. It is also used for translations, so its value should be the same as the corresponding element in the schema page. Further information is presented in the translation section.
- `required`: indicates if the field is required or not. This parameter is *optional* and defaults to true.
- `type`: defines the input type. Available values are the appropriate values for an html input tag (text, URL, email, tel, etc.) included in a way similar as `<input type="{{ widget.type }}">`. This parameter is *optional* and defaults to "text".
- `rule`: specifies a custom rule of validation. Available rules can be found in `_data/forms/rules.yml`. You can use any of the key (`key: value`) you may find in this document as a value for the rule parameter. This parameter is *optional* and defaults to none.
  - To see how the rules work, see the following file: `assets/js/src/custom-form-validation.js`.
- `more`: Specifies if a field or group of fields can be filled more than once. This allow the user to add more than one value. It is used for arrays element, and hooks a bunch of JavaScript.

The following sections explain each of the available widgets:

- group
- select
- string-i18n
- string

#### group

The group widget displays a list of other widgets under a single title.

This widget takes one additional parameter, in addition to the ones available to widgets.

- `fields`: an array of widgets and their own parameters to display in the same logical group.

```yaml
  - widget: group
    title: example
    param: {...}
    fields:
      - widget: string
        title: test1
        param: {...}
      - widget: string-i18n
        title: test2
        param: {...}
      [...]
```

The widget declaration under "fields" acts the same way as if they were declared as top-level fieldGroups.

This widget make use of the widget not specified in the above list of all widgets: select-group, string-group and string-i18n-group. They're basically the same as their non-group counterparts but usually don't include a title.

*NOTE* : It is not possible to add presets to group widgets.

#### select

The select widget allow to create a `<select>` tag with a list of options as parameters

This widget takes one additional parameter in addition to the ones available to widgets.

- `options`: a list of the options available as an array.

```yaml
  - widget: select
    title: example
    param:
      options: {a, b, c}
```

The options values are also used for the value attribute of the option tag (`<option value="{{ option[i] }}"`). These options are also the keys used for the translations. For further information, check the translation section.

#### string-i18n

The string-i18n widget displays two fields for a single value (in english and french).

This widget takes all the parameters available to widgets.

```yaml
  - widget: string-i18n
    title: example
```

This widget takes also an additional parameter that was added to fix a duplicate id error in the html markup but was later made obsolete. We didn't bother to remove the code for it, so it's still available as a parameter but not used anywhere.

- `prepend`: A string to prepend to the id when generating the html markup. It allows to keep the title parameter clear (since it's used in the schema as well as for translations) without creating conflicts in ids.

#### string

The string widget displays a single field for values.

This widget takes all the parameters available to widgets.

```yaml
  - widget: string
    title: example
```

### Creating a new Widget

Creating a widget is similar to creating a preset, but follows a more generic idea. Create a new widget only when multiple form components follow the same basic structure. A widget shouldn't be complex and should allow for more variations than the presets.

#### Add your new widget in the form components

Under `_includes/form/widgets/`, create a file for your new widget. Its name should follow camelCase convention. Fill it with html markup, use inspiration from other widgets, and, if possible, include components in it instead of adding new code.

```yaml
  - widget: example
    param: {test: myValue}
```

The value of `test` can then be accessed in your widget as `include.param.test`.

#### Add your new widget in the schema components

Under `_includes/schema/widgets/`, create a file for your new widget. Its name should match the one you previously created in the form folder. To fill it, follow the same advice as for the form.

## Includes

### The loop

The loop is pretty straightforward. It loops through all the `formGroup` elements and include the file related to its name in the widget or preset folder. It also passes all parameters and other useful variables

### Components

Components are even more generic than widgets. They were created to reduce the duplication of code and to ensure the following of the style guide.

Also, in the form components, you can find the admin folder which specifies the components specific to the new admin form that shows up when the user creates a new administration. They are included in the adminCode preset as well as the partner preset.

## Translations

Translations for the form and schema pages are located in `_data/i18n/form.yml`. They are separated in sections for more generic translations and in first-level groups for each of the forms.

## Yaml Variables

In general, you can create variables in Yaml files:

- Use `&variable` for instantiation, where *variable* represents the name of the variable you wish to create
- Use `*variable` when you intend to use the variable

In this particular project, variables are created to declare and to use generic values (name, email, URL, etc.). But the neat thing is that it can act as a string or as an object, so we can easily wrap translations inside a single variable. Here's an example of what it looks like in the files:

```yaml
name: &name
  en: Name
  fr: Nom
[...]
example:
  label: *name
```

It is equivalent to:

```yaml
name:
  en: Name
  fr: Nom
[...]
example:
  label:
    en: Name
    fr: Nom
```

### Presets

All the presets translations are already included. When modifying  any of the presets files (`_includes/[form_or_schema]/presets/`), you should also check the translations.

When creating a new preset, it should be added under the presets first-level group, unless you specified a different parameter in the loop (`includes/[form_or_schema]/loop.html`).

- In general, when including the file, the preset ID is specified to "presets": `{% include file.yml id=idPreset %}`
- However, you can use the variable `id` instead of `idPreset` when you intend to use the ID that is defined in the config page. This means that you should put the translations under the equivalent first-level element named after the `id` instead of the text "preset".

### Translations for Widgets

Here's how to translate widgets:

- For each widget, add a second-level element (under the first-level named after `id`). Its name should be the same as the value you put under `title` in the config file. The title should be the same as the value in the schema page since it's included as is in the schema page.

```yaml
first-level:  # either preset, admin, code, software, standard, etc...
  example:  # replace example with the title value of the widget
    [...]
```

- You will also need to add a title element under it. Don't mistaken it for the second-level element, where title should be replaced with the title value of the current widget. This title is a third-level element named title which will hold the english and french value for the title. This value appears in the form page as a section's title and as the section description in the schema page:

```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
```

Each widget has also other specific elements that need to be added. The following sections describe each of theses elements.

#### String Widget

For a string widget, follow this template:

```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    label:
      en: The english label
      fr: The french label
```

#### String-i18n Widget

For a string-i18n widget, follow this template:

```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    labels:
      en:
        en: The english label for the english page
        fr: The french label for the english page
      fr:
        en: The english label for the french page
        fr: The french label for the french page
      schema:
        en: The generic english label for the schema (without specificity for either english of french)
        fr: The generic french label for the schema (without specificity for either english of french)
```

#### Select

For a select widget, follow this template:

```yaml
first-level:
    example:
      title:
        en: Example
        fr: Exemple
      options:
        option-name:  # where option-name is the value added in the options array in the config file
          en: Option
          fr: Option
        [...]
```

#### Group

For a group widget, the values under `labels` depends on the fields' widget type. Follow this template:

```yaml
first-level:
  title:
    en: Example
    fr: Exemple
  labels:
    string:  # replace string with the title of a string widget
      en: The english value for the label
      fr: The french value for the label
    string-i18n:  # replace string-i18n with the title of a string-i18n widget
      en:
        en: The english value for the english page
        fr: Then french value for the english page
      fr:
        en: The english value for the french page
        fr: The french value for the french page
  titles:
    widget-name:  # replace widget-name with each widget names
                  # The title is used for the schema page
      en: Widget Name
      fr: Nom du widget
    [...]
```

## JavaScript

Each form needs its own custom JavaScript which you will have to create.

All the scripts are located under `assets/js/src/`. The scripts for each form follows the naming convention `[form_id]Form.js` with camelCase. There are also other scripts that fall under the utility category (i.e. date, more-group, partners, programmingLanguages, tags). These are included either all pages or specifically in certain form pages. See the footer links section below for more informations.

### Footer links

Links to the scripts are added in the footer include, located in `_includes/footer.html`.

It is also possible to add a script only on certain pages as we did for specific forms. Use a condition on the page reference value to do so:

```html
{%- if page.ref == "example" -%}
  <script src="path/to/file.js"></script>
{%- endif -%}
```

At the very bottom of the footer file, there's an inline script declaring some constants that are used in other script files: `REPO_NAME`, `USERNAME`, and `PRBOT_URL`. Their values are taken from the `_config.yml` and pulled through Jekyll/Liquid.

### PRB0T

[PRB0T](https://github.com/PRB0t/PRB0t) is an open source solution we [forked](https://github.com/j-rewerts/PRB0t) and customized to fit our specific needs. It was used with the forms in order to submit changes. Basically, we merge the necessary files with the new content pulled from the form, and then we submit a, anonymous pull request in the canada-ca ore-ero Github repo.

### Javascript files

#### Eslint validation

At the beginning of the file, there's a comment beginning with the keyword `global` that defines which function used in the file are taken from other files. Additionally, there might be another comment starting with the keyword `exported` that defines functions that are declared in the file but used in another.

#### Submit functions

When submitting the form, we first validate the form and initiate the alerts. We continue only once it's validated using the `submitInit()` function from the `validation.js`.

Most form use two very similar submit functions. One for submitting the form with a new administration (when the user created a new administration instead of selecting an existing one in the adminCode preset), and the other without a new administration. This is regardless of the new administrations created through the partners preset.

#### Reset

Some forms require a specific function for reset, especially when dealing with tags and programming languages. The user is able to add and remove tag fields and we want to make sure to reset those fields since the basic reset does not take care of that by default.

#### getObject

The `get[form_id]Object()` function takes all the values from the form inputs and assigns them to an object variable. That object follows the hierarchy as the schema for the form (its order defines in which order the fields will appear in the data file). It is separated into two sections. First, all mandatory fields are added to the object. Then, the function probes each single non-mandatory field, checking whether it has a value or not. In case it has a value, the non-mandatory field is added to the object. That way, no keys with empty values will be added to the data files.

#### addValuesToFields / resetFields

When the user selects an already existing project or administration, data is pulled from github. The addValuesToFields fills some input fields with the fetched data. Now if the user chooses to change back the select to its default null value, the resetField removes the values that were added automatically to the input fields from fetched data.
In both cases, not all form fields are modified automatically. For instance, in the open software form, selecting an existing software and selecting an existing administration do not fill the same fields, and resetting one select does not mean that the other select also needs resetting.

----

# Solution pour générer automatiquement les formulaires et leurs schémas.

Inspiré des principes de base de [Netlify Cms](https://www.netlifycms.org/), ce système a été mis en place afin de mieux répondre aux caractéristiques de ce projet.

Cette documentation a pour objectif d'expliquer comment générer automatiquement des pages de formulaires et de schémas à partir des données d'un seul fichier `yml`, tout en respectant le layout des pages et les traductions du dossier `_data/il8n`. Il existe cependant une limite à cette automatisation et l'ajout manuel de scripts (JavaScript) demeure nécessaire au bon fonctionnement du formulaire.

Ce document explique comment les éléments de la solution fonctionnent. Il contient également des instructions sur comment les utiliser, comment les mettre à jour et comment en créer de nouveaux.

## Pages

Pour assurer la récupération de toutes les données à configurer, les pages doivent suivre un certain modèle qui sera présenté dans cette section. Vous trouverez les pages dans le dossier `_pages/`.

**ATTENTION** : Lorsque des pages sont créées ou mises à jour, assurez-vous d'appliquer les changements dans les deux langues! Vous trouverez les pages correspondantes dans les dossiers `_pages/en` et `_pages/fr`. Cherchez les pages ayant une même valeur pour le paramètre `ref` dans leurs entêtes.

Les variables à inclure au niveau de l'entête des pages sont présentées ci-dessous. Celles-ci devraient être incluses dans tout formulaire et schéma (un exemple suivra).

- `layout` : définie la structure de mise en page à suivre. Par défaut, cette variable a pour valeur "default". Les layouts sont situées dans le dossier `_layouts/`.
- `ref` : il s'agit d'un ID unique qui différencie entre les différentes pages. Cependant une page en français aura un même ID que sa page équivalente en anglais et vice-versa, permettant ainsi la redirection des pages web au moment où un changement de langue est effectué.
- `lang` : correspond à la langue associée à la page. Utilisée le plus souvent comme `[page.lang]`, cette variable permet de sélectionner la bonne valeur pour une traduction. Les valeurs acceptés sont `en` et `fr`.
- `permalink` : correspond au permalien de la page (au moins la partie qui sera ajoutée au URL de base du site) qui remplacera l'emplacement du fichier dans les dossiers lorsque le site internet sera compilé. Suivre la convention suivante `/[lang]/[page_name]`.

### Exemple d'entête pour une page normale

```yaml
---
layout: default
ref: exemple
lang: fr
permalink: /fr/exemple.html
---
```

### Page de formulaire

Les pages de formulaire nécessitent les ajustements suivants au niveau des variables :

- `layout` : les pages de formulaire ont la valeur `form` par défaut pour la variable `layout`au lieu de la valeur "default".
- `Config` : correspond au nom du fichier Yaml dans le dossier `_data/forms/` qui est associé au formulaire actuel. Ainsi, la relation entre le layout actuel et les données requises pour le formulaire est créée.

#### Exemple d'entête pour une page de formulaire

```yaml
---
layout: form
ref: exempleForm
lang: fr
permalink: /fr/exemple-form.html
config: exemple-config  # Ira chercher _data/forms/config-example.yml
---
```

### Page de schéma

Les pages de schéma possèdent les même variables d'entête que les formulaires, mais plutôt, la valeur "schema" serait définie pour le paramètre `layout`. De plus, la page de formulaire et la page de schéma qui sont associées l'une à l'autre doivent avoir une même valeur pour le paramètre `config` pour permettre l'extraction des mêmes données.

#### Exemple d'entête pour une page de schéma

```yaml
---
layout: schema
ref: exempleSchema
lang: fr
permalink: /fr/exemple-schema.html
config: exemple-config
---
```

## Layouts

Les pages de schéma et de formulaire suivent toujours les mêmes *layouts* : le *form layout* et le *schema layout*. Cette forme permet d'ajouter tout contenu spécifique à la page en question. Ces derniers se comportent comme un gabarit ou une mise en page où les données extraites du fichier *config* seront ajoutées.

### *Form layout*

Situé dans le dossier `_layouts/form.html`, il hérite du *layout* par défaut pour inclure l'entête, le bas de page et d'autres composantes fixes du site web.

#### Comment ça marche

Tout d'abord, le contenu de la page est ajouté au *layout* via la ligne de code `{{ page.content }}`.
Par la suite, se trouve le *form tag*. Celui-ci comprends :

- Les *classes* et les *id* nécessaire pour le *plugin* de validation du formulaire (provient avec le modèle [WET-BOEW](https://wet-boew.github.io/wet-boew/docs/ref/formvalid/formvalid-en.html)).
- La définition de la variable `idPresets`. Elle fait directement référence au groupe de premier niveau *presets* dans le fichier de traduction.
- La "pièce de résistance" : un appel à la boucle du formulaire (`loop.html`), permettant de chercher les valeurs dans le fichier *config* et de les ajouter au formulaire, grâce à la fonctionnalité `include`.
- Un second *include call* (juste après l'appel de la boucle) afin d'inclure le fichier du *submitter*. Les informations de l'auteur d'un formulaire sont nécessaires pour la création de *pull requests* afin de préserver une trace de l'auteur en question.
- Les boutons *submit* et *reset*. Il est à noter que le bouton *submit* a un id unique correspondant à `prbotSubmit{{ page.ref }}` où `{{ page.ref }}` fait référence à la valeur du paramètre `ref` dans l'en-tête de la page.

Ces éléments ne sont ni dans la page même ni dans le fichier *config*. On les retrouve plutôt dans le *layout* sachant qu'ils doivent tous apparaître dans la page du formulaire quelque soit le formulaire auquel la page réfère.

### Layout de schéma

Situé dans le dossier `_layouts/schema.html`, il hérite du "layout" par défaut pour inclure l'en-tête, le bas de page ainsi que d'autres composantes fixes du site web.

#### Comment ça marche

Tout d'abord, le contenu de la page est ajouté au *layout* via la ligne de code `{{ page.content }}`. Cette forme permet d'ajouter tout contenu spécifique à la page en question. Par la suite, une boucle similaire à celle du formulaire est ajoutée.

## Fichiers *config*

Ces fichiers représentent le cerveau de la solution. Ils spécifient chaque composant ainsi que leurs paramètres devant être inclus dans le formulaire et son schéma correspondant.

**Voici un exemple de fichier :**
Note : Les "presets" et "widgets" disponibles, ainsi que leurs paramètres, seront présentés après cet exemple, dans leurs sections réservées

```yaml
---

id: exemple
formGroups:
  - preset: unPreset
  - widget: unWidget
    title: unTitre
    param: {unParam: uneValeur}
```

### Presets

Situé sous le dossier `_includes/[form_or_schema]/presets/`, les *presets* représentent des sections statiques contenant un ensemble de paramètres prédéfinis. L'ajout de paramètres est rarement nécessaire pour ces sections. Les *preset* sont créés dans une des situations suivantes :

- lorsqu'une section est présente dans plusieurs formulaires, dans le but de réduire la duplication de code
- lorsqu'une section est très spécifique et que les widgets déjà présents ne permettent pas sa création. Ceci est le cas si les modifications spécifiques ne peuvent pas être ajoutés en temps que paramètres, ou si le format correspondant est différent de tous les widgets déjà présents.

Voici une liste des *presets* disponibles :

- adminCode
- category
- contact
- description
- empty (*schéma seulement)*
- homepageURL
- hr
- languages
- licenses
- name (*formulaire seulement*)
- partners
- relatedCode
- selectCode, selectPartnership, selectSoftware et selectStandard
- status
- submitter
- tags
- team

Les paramètre des presets sont situés dans des fichiers séparés situés dans le dossier `_data/forms/[preset_name].yml`.

Les sections suivantes présentent une explication de chacun des *presets* disponibles.

#### AdminCode

L'*adminCode* affiche un menu de sélection (`<select>` widget) pour les administrations. Celles-ci sont séparées par groupe selon le niveau de gouvernement : fédéral, provincial, municipal et autochtone. La liste des administrations se trouve sous le dossier suivant : `_data/administrations/[level_of_gov.].yml`.

Le menu est suivi d'un bouton permettant à l'utilisateurs de créer une nouvelle administration au cas où son administration n'était pas déjà présente dans liste. Une nouvelle section est alors ouverte dans le formulaire et des champs obligatoires sont à remplir. Consultez la section **newAdmin** de la documentation pour de l'information sur ces champs.

Lorsqu'une administration est sélectionnée, du JavaScript est utilisé pour remplir automatiquement la section de l'administration du formulaire, dépendamment de son type. La même logique est suivie pour les *presets* **selectCode**, **selectPartnership**, **selectSoftware** et **selectStandards**.

L'adminCode ne prend pas de paramètres additionnels :

```yaml
- preset: adminCode
```

#### Contact

Ce *preset* affiche un ensemble de champs relatif aux coordonnées de la personne (ou de l'organisation) à contacter pour des informations générales sur le projet ouvert auquel le formulaire fait référence.

Ce *preset* accepte un seul et unique paramètre (celui-ci est **optionnel** ) selon le type de formulaire :

- `phone` : Paramètre booléen permettant de savoir si ce champ (phone/téléphone) devrait être ajouté. Sa valeur par défaut est `false`.

```yaml
- preset: contact
  phone: true  #bool
```

#### Description

La *description* regroupe deux catégories (Ce que ça fait, et comment ça fonctionne) qui chacune ont un champ pour les deux langues. Ce *preset* a été créé car tous les formulaires ont un champ description.

Ce *preset* ne prend pas de paramètres additionnels.

```yaml
- preset: description
```

#### Empty

Ce *preset* n'affiche rien dans le formulaire. Celui-ci permet d'adapter la structure de données d'un formulaire afin qu'il corresponde à la structure d'un schéma. Par exemple, pour la structure de données du schéma du *release* (`_data/schemaCode.yaml`), il ne ferait pas de sens de changer complètement le *layout* du formulaire pour l'adapter à ce schéma sachant qu'un seul *release* peut être mis à jour à la fois.

Ce *preset* prend deux paramètre **obligatoires** :

- `start` : Définit s'il s'agit du début ou de la fin de la structure de données dans le schéma.
- `title` : Nom de la structure de donnée dans le schéma (également utilisé pour les traductions, voir la section des *widgets* pour plus d'informations).

```yaml
- preset: empty
  start: false  # bool
  title: exemple
# Beginning a group / array
```

OU

```yaml
- preset: empty
# Closing a group / array
```

Les balises de début et de fin sont situées dans les dossiers suivants : `_includes/schema/components/wrap_start.html` et `_includes/schema/components/wrap_end.html`. Ce sont les fichiers incluent dans les pages de **schéma**.

#### HomepageUrl

Ce *preset* affiche deux champs pour les deux langues, soit EN et FR. Chaque champ correspond à l'URL de la page d’accueil (pour chaque langue).
Ce *preset* ne prend pas de paramètres additionnels.

```yaml
- preset: homepageUrl
```

#### HR

Ce *preset* a été mis en place afin d'identifier les sections dont les champs peuvent se remplir automatiquement dépendamment de l'entrée. Par exemple, dans le formulaire pour les logiciels libres, la sélection d'un projet existant remplira automatiquement les champs déjà enregistrés (l'utilisateur n'aura qu'à compléter les parties manquantes)

**NOTE** : Ce *preset* n’apparaît pas dans le schéma et ne prend pas de paramètres additionnels.

```yaml
- preset: hr
```

#### Languages

Ce *preset* permet d'afficher une liste de langages de programmation à sélectionner (l'utilisateur sélectionner ceux étant associé à son projet). De plus, celui-ci permet à un quelconque utilisateur d'ajouter son propre langage s'il ne le trouve pas dans la liste.

Ce *preset* ne prend pas de paramètres additionnels.

```yaml
- preset: languages
```

#### Licenses

Ce *preset* affiche deux zones de texte pour l'URL des licences selon chaque langue, soit EN et FR. On retrouve également un autre champ pour le spdxID de la licence. Le *label* pour le spdxID contient un lien vers une liste et définition de spdxID (juste au-dessus de la zone de texte).

Ce *preset* ne prend pas de paramètres additionnels.

```yaml
- preset: licenses
```

#### partners

Le *preset* *partners* est l'un des plus complexes. Il a aussi beaucoup de JavaScript associé. Il permet aux utilisateurs de créer de nouvelles administrations ou d'en sélectionner une existante pour l'ajouter en tant que partenaire en y ajoutant certaines informations de contact spécifique aux partenaires.

Ce *preset* ne prends pas de paramètre additionnels.

```yaml
- preset: partners
```

#### RelatedCode

Ce *preset* affiche 4 champs :

- Les URL (FR et EN) relatifs au code.
- Les noms (FR et EN) relatifs au code.

Il ne prend pas de paramètres additionnels.

```yaml
- preset: relatedCode
```

#### selectCode, selectDesign, selectPartnership, selectSoftware et selectStandard

Ces six *presets* affichent un menu de sélection (un *widget*) permettant à un quelconque utilisateur de sélectionner un projet (déjà existant) afin de le modifier ou bien d'y ajouter des éléments lui étant reliés (administrations, etc.). Ils permettent **principalement** de remplir automatiquement la section correspondante du formulaire lorsqu'un projet est sélectionner grâce au JavaScript (ils suivent le même principe que l'*adminCode*).

Ces trois *presets* ne prennent pas de paramètres supplémentaires.

```yaml
- preset: selectCode
```

#### Statuts

Ce *preset* affiche un `<select>` *input* correspondant aux possible statuts du projet (*alpha*, *bêta*, maintenu, déprécie ou retraité).

Il ne prend pas de paramètres additionnels.

```yaml
- preset: status
```

#### Submitter

Affiche une section séparée du formulaire demandant à l'utilisateur ses informations (nom et email) afin de garder une note de celui qui a soumis le formulaire.

**NOTE** : Il n'est pas nécessaire d'inclure ce *preset* dans les fichiers de configurations sachant qu'il est déjà inclus dans le *layout* du formulaire.

#### Tags

Ce *preset* affichent des champs permettant d'ajouter des tags à un quelconque projet. Il existe des sections pour l'anglais et le français.

Celui-ci ne prend un paramètre *optionnel*.

```yaml
  - preset: tags
    param: {required: false}  # defaults to true
```

### Créer un nouveau *preset*

Cette section présente les étapes relatives à la création d'un nouveau *preset*. Avant tout, assurez-vous que la création de celui-ci est réellement nécessaire. En effet, comme dit précédemment, un nouveau *preset* peut être créé lorsqu'un composant revient dans plusieurs formulaires ou lorsqu'un composant a une structure assez spécifique et ne suit aucun widget déjà présent. Cependant, pour une nouvelle structure qui est récurrente, créer un widget générique peut être avantageuse et une réflexion s'avère nécessaire pour prendre une bonne décision.

#### Ajoutez votre nouveau *preset* dans les composantes d'un formulaire

Pour commencer, créer un nouveau fichier pour votre nouveau *preset* dans le dossier `_includes/form/presets/`. Le nom du fichier doit suivre la convention *camelCase*. Remplissez le d'un balisage HTML. N'hésitez pas d'utiliser les autres *presets* comme source d'inspiration et d'inclure alors des widgets en utilisant des paramètres spécifiques quand ils se répètent dans plusieurs formulaires.

```yaml
- preset: example
  param: {test: uneValeur}
```

Vous pourriez accéder à la valeur de `test` de cet exemple dans votre *preset* en utilisant `include.param.test`. En effet, *Include* est le terme employé pour accéder à tous les paramètres déclarés (dans tous les fichiers) dans le dossier `_includes/`. Notez que le même principe est applicable pour `page.test` dans `_pages/`. Les données sont cependant un peu différentes et l'utilisation de `site.data.test` (où "test" désigne un fichier ou un dossier dans `_data/`) est requise.

#### Ajoutez votre nouveau *preset* dans les composantes d'un schéma

Créez un nouveau fichier pour votre *preset* dans le dossier `_includes/schema/presets/`. Son nom doit correspondre au nom du fichier déjà créé dans le dossier du formulaire. Pour remplir le fichier, suivez les recommandations développées précédemment pour l'ajout du *preset* dans les composantes du formulaire.

### Widgets

Contrairement aux *presets*, les *widgets* sont des sections beaucoup plus flexibles dont l'ajout de paramètres est beaucoup plus fréquent (le nombre de paramètres est également plus élevé). Ceux-ci peuvent ainsi être configurés afin d'être mieux adaptés aux différentes sections du formulaire.

Voici un exemple de *widget* :

```yaml
- widget: example  #enum
  title: ~
  param: {unParam: uneValeur}
```

#### Paramètres et valeurs par défaut

L'example suivant démontre la liste des paramètres et leur valeurs par défaut.

- `~` indique qu'il n'y a pas de valeur par défaut
- `enum` indique que seule certaines valeurs sont appropriées

```yaml
  - widget: unWidget  #enum
    title: unTitre
    param: {
      required: true,
      type: ~,  #enum
      type: ~,  #enum
      more: false
    }
```

Dans cet example :

- `widget` (**obligatoire**) : définit le type de *widget* à inclure. Ce paramètre doit impérativement être définit, sinon, le formulaire affichera un message d'erreur.
- `title` (**obligatoire**) : définit le titre du *widget*. Il est unique à chaque *widget*, à l'Exemption de quelques uns. Ce paramètre est important puisqu'il affiche le texte relatif au *widget*. La valeur associée à ce paramètre doit être identique à l'élément correspondant dans la page de schéma, afin de rendre la traduction du *widget* possible.
- `required` : définit si un champs dans le *widget* est obligatoire ou pas. Par défaut, tous les champs sont obligatoires. Il faut donc spécifier lorsqu'un champ est optionnel.
- `type` (**optionnel**) : définit le type d'entrée du *widget*, en utilisant `<input type="{{ widget.type }}">`. Les entrées possibles sont les valeurs de bases fournis par HTML (soit email, URL, *text*, etc.). La valeur par défaut de ce paramètre est *"text"*.
- `rule` (**optionnel**) : définit les règles de validation pour une entrée quelconque. Des règles sont disponibles dans le fichier `_data/forms/rules.yml`. Vous pouvez utiliser n'importe quel *key* (`key: value`) que vous trouverez dans ce document comme valeur pour ce paramètre. Sa valeur par défaut est "*none*".
- `more` (**optionnel**) : Indique qu'un utilisateur peur remplir un champ ou un groupe de champs plusieurs fois. C'est utilisé pour les *arrays* et est associé à plusieurs fonctions JavaScript.

Voici une liste des *widgets* disponible :

- group
- select
- string-i18n
- string

Les sections qui suivent expliquent chacun des *widgets* disponibles.

#### group

Ce widget correspond à une liste ou un groupe de *widgets*, disponible sous un seul titre. Il prend un paramètre additionnel, incluant ceux présentés précédemment :

- `fields` : il s'agit d'un tableau de *widgets* et leurs paramètres à afficher dans un même groupe logique.

Par exemple :

```yaml
- widget: group
  title: example
  param: {...}
  fields:
    - widget: string
      title: test1
      param: {...}
    - widget: string-i18n
      title: test2
      param: {...}
   [...]
```

La déclaration d'un *widget* sous "*fields*" est similaire à sa déclaration comme étant un haut niveau *fieldGroup*.
La déclaration des *sous-widgets* se fait de la même façon qu'un quelconque *widget*.

*NOTE* : Il n'est pas possible d'ajouter des *presets* à ce type de *widget*.

#### Select

Ce *widget* permet de générer le tag HTML `<select>` en définissant une liste d'option comme paramètres.

Ce *widget* prend un paramètre  additionnel, incluant ceux présentés précédemment :

- `options` : un tableau contenant les options disponibles.

```yaml
- widget: select
  title: example
  param:
    options: {a, b, c}
```

Les valeurs disponibles dans le tableau sont utilisées aussi pour la traduction (voir la section traduction pour plus d'informations). Elles peuvent aussi être utilisées pour l'attribut *value* du "tag *option*" (`<option value="{{ option[i] }}"`).

#### string-i18n

Ce *widget* affiche deux champs pour une seule valeur (français et anglais). Il prend tout les paramètres disponibles pour un *widget*.

```yaml
- widget: string-i18n
  title: example
```

Un paramètre supplémentaire a été ajouté par la suite dans le but de corriger une erreur relative aux ID, mais qui en fin de compte n'a pas été utilisée. Nous ne l'avons pas retiré car la fonctionnalité que cela permet pourrait être utile dans le futur :

- `prepend` : il s'agit d'un *string* à ajouter à l'ID lorsqu'on génère les balises HTML. Ceci permet d'avoir deux fois le même le paramètre `title` tout en évitant la création de conflits entre les ID.

#### string

Ce widget affiche un champ unique pour les valeurs ne nécessitant pas de traduction. Il prend tout les paramètres disponibles pour un *widget*.

```yaml
- widget: string
  title: example
```

### Créer un nouveau *widget*

La création d'un *widget* est très similaire à la création d'un *preset*. Créez un *widget* uniquement lorsque plusieurs composantes d'un formulaire suivent une même structure. Notons qu'un *widget* devrait être simple et plus flexible qu'un *preset* en terme d'alteration.

#### Ajoutez votre nouveau widget dans les composants du formulaire

Tout d'abord, créez un nouveau fichier pour votre *widget* dans le dossier `_includes/form/widgets/`. Le nom du fichier doit suivre la convention *camelCase*. Ajoutez-y ensuite le balisage HTML. N'hésitez pas à utiliser les autres *widgets* comme source d'inspiration et à inclure des composantes au lieu d'ajouter des nouvelles lignes de code dans la mesure du possible.

```yaml
- widget: example
  param: {test: myValue}
```

Vous pourriez accéder à la valeur de `test` de cet exemple dans votre *preset* en utilisant `include.param.test`.

#### Ajoutez votre nouveau *widget* dans les composantes de votre schéma

Créez un nouveau fichier pour votre *widget* dans le dossier `_includes/schema/widgets/`. Son nom doit correspondre au nom du fichier déjà créé dans le dossier du formulaire. Pour remplir le fichier, suivez les recommandations développées précédemment pour l'ajout du *widget* dans les composantes du formulaire.

## Includes

### Les *loops*

La boucle est plutôt simple. Elle boucle au travers de tous les éléments sous `formGroup` dans le fichier de configuration et inclus les fichiers dont le nom corresponds au nom du *widget* ou du *preset*. La boucle passe aussi tous les paramètres nécessaires aux *includes*.

### *Components*

Les *components* sont beaucoup plus génériques que les *widgets* et ont été créé dans le but de diminuer la duplication de code et pour assurer que le HTML suit le guide de style.

De plus, dans le dossier `form/components`, on retrouve le dossier `admin` qui spécifie les éléments du sous-formulaire pour la création d'une nouvelle administration soit dans le *pop-up* du *preset* adminCode ou dans le *preset* partners.

## Traductions

Les traductions pour les formulaires et schémas se trouvent dans le fichier `_data/i18n/form.yml`. Elles sont séparées en sections pour les *presets* et pour tous les formulaires individuels.

## Variables YAML

En général, il est possible de créer des variables dans les fichiers YAML :

- Pour instancier, utilisez la syntaxe `&variable` (où *variable* représente le nom de votre variable YAML).
- Pour utiliser la variable en question, utilisez la syntaxe `*variable`.

Pour ce projet en question, la création d'une variable dans les fichiers YAML a permit de déclarer et d'utiliser des valeurs plus génériques (*name*, *email*, URL, etc.). La particularité de cette fonctionnalité est que la variable peut agir en tant que *string* ou bien en tant qu'*objet*. Ainsi, il est possible d'envelopper des traductions dans une seule variable.

Voici un exemple pouvant être retrouvé dans un quelconque fichier :

```yaml
name: &name
  en: Name
  fr: Nom
[...]
example:
  label: *name
```

Ce qui est l'équivalent de :

```yaml
name:
  en: Name
  fr: Nom
[...]
example:
  label:
    en: Name
    fr: Nom
```

### Presets

Toutes les traductions des *presets* sont déjà incluses. Alors, lorsque vous modifiez l'un des *presets*, veuillez appliquer les modifications pour sa traduction également.

Lors de la création d'un nouveau *preset*, les traductions (pour les éléments en nécessitant) doivent être ajoutées sous le groupe de premier niveau des *presets*.

- En général, durant l'appel du fichier, la valeur "presets"  est assignée au paramètre *id* des *presets* : `{% include file.yml id=idPreset %}`.
- Vous pouvez utiliser la variable `id` au lieu de `idPreset` quand vous désirez utiliser l'id défini dans la page *config*. Ainsi, pour éviter tout type d'erreur, les traductions doivent être ajoutées sous l'élément du premier niveau correspondant portant le nom de `id` au lieu de la chaîne de caractères "*preset*".

### Widgets

Voici la bonne façon pour traduire un *widget* :

- Pour chaque *widget*, ajoutez un élément au deuxième niveau (sachant que le premier niveau peut correspondre à *preset*, *admin*, *software*, etc.). Le nom de ce paramètre doit être identique à la valeur du paramètre `title` présente dans le fichier *config*.Par exemple :

```yaml
first-level:  # soit preset, admin, code, software, standard, etc...
  example:  # remplacer example avec la valeur pour title du widget
   [...]
```

- Vous aurez également besoin d'ajouter un paramètre au troisième niveau sous le nom de `title`. Ce paramètre renferme la version française et anglaise de la valeur qui le définit. Cette valeur (du paramètre `title`) apparaît en tant que titre d'une section dans la page de formulaire ainsi qu'en description dans la page de schéma. Voici un exemple permettant d'illustrer cette explication :

```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
```

L'exemple ci-dessus représente le modèle de base associé à chaque *widget*. Cependant, chaque *widget* a ses éléments spécifiques à ajouter. Ces éléments sont présentés dans les quatre sections qui vont suivre.

#### String

Voici le modèle à appliquer à ce *widget* :

```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    label:
      en: The english label
      fr: The french label
```

#### String-i18n

Voici le modèle à appliquer à ce *widget* :

```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    labels:
      en:
        en: The english label for the english page
        fr: The french label for the english page
      fr:
        en: The english label for the french page
        fr: The french label for the french page
     schema:
       en: The generic english label for the schema (without specificity for either english of french)
       fr: The generic french label for the schema (without specificity for either english of french)
```

#### Select

Voici le modèle à appliquer à ce *widget* :

```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    options:
      option-name:  # où option-name est la valeur ajoutées dans le tableau options du fichier config
        en: Option
        fr: Option
  [...]
```

#### Group

Voici le modèle à appliquer à ce *widget* :

```yaml
first-level:
  title:
    en: Example
    fr: Exemple
  labels:
    string:  # remplacer string avec le titre d'un widget de type string
      en: The english value for the label
      fr: The french value for the label
    string-i18n:  # remplacer string-i18n avec le titre d'un widget de type string-i18n
      en:
        en: The english value for the english page
        fr: Then french value for the english page
      fr:
        en: The english value for the french page
        fr: The french value for the french page
    titles:
      widget-name:  # remplacer widget-name avec le nom de chacun des widgets
                    # title est utilisé pour la page schéma
        en: Widget Name
        fr: Nom du widget
[...]
```

## Javascript

Chaque formulaire nécessite son propre JavaScript personnalisé.

Tous les scripts se situent dans le dossier `assets/js/src/`. Les scripts de chaque formulaire suivent la convention *camelCase* (soit `[form_id]Form.js`). Certains scripts sont inclus dans la catégorie des utilitaires (i.e. date, more-group, programmingLanguages, tags). Ils sont inclus soit dans toutes les pages, ou dans certaines pages de formulaire spécifique. Voir les la section liens de bas de page ci-dessous pour plus d'informations.

### Liens dans le *footer*

Les liens vers les scripts sont ajoutés dans le *footer* se trouvant dans le fichier HTML suivant : `_includes/footer.html`.

Il est aussi possible d'ajouter un script seulement sur une page de formulaire spécifique. Il suffit d'utiliser un `if/else` sur le référence d'une page :

```html
{%- if  page.ref == "example"  -%}
<script  src="chemin/vers/le/fichier.js"></script>
{%- endif  -%}
```

Au bas du fichier, un morceau de script est présent permettant de déclarer certaines constantes utilisées dans d'autres fichiers de script : `REPO_NAME`, `USERNAME` et `PRBOT_URL`. Leurs valeurs de ces paramètres sont récupérées du fichier *yml* `_config.yml` via Jekyll/Liquid.

### PRB0T

[PRB0T](https://github.com/PRB0t/PRB0t) est une solution *open source* qui a été "*[forked](https://github.com/j-rewerts/PRB0t)*" et personnalisée afin de satisfaire nos besoins. En bref, lorsque le formulaire est soumis, il fusionne les fichiers nécessaires avec le nouveau contenu tiré du formulaire puis soumet une "*pull request*" anonyme au répertoire GitHub du projet.

### Fichiers JavaScript

#### Validation Eslint

Au début de chaque fichier se trouve un commentaire débutant par le mot-clé `global`. Cela définit des fonctions qui sont utilisées dans le fichier mais qui sont définies dans d'autres fichiers. De plus, il se peut qu'il y ait un second commentaire débutant par le mot-clé `exported`, définissant à l'inverse, des fonctions définies dans le fichier mais utilisées ailleurs.

#### Fonctions *submit*

Avant d'être soumis, les formulaires sont d'abord validés à l'aide de la fonction `submitInit()` du fichier `validation.js`.

La plupart des fichiers JavaScript des formulaires utilisent deux fonctions pour soumettre le formulaire. L'une permet d'ajouter une nouvelle administration (lorsque l'utilisateur a créé une nouvelle administration plutôt que d'en sélectionne une via le *preset* adminCode), et l'autre sans l'ajout d'une nouvelle administration. Ceci n'est pas influencé par la création de nouvelle administrations crées grâces au *preset* partners.

#### *Reset*

Certains formulaires nécessitent une fonction spécifique pour la réinitialisation. Particulièrement lorsqu'il s'agit de mots-clés et de langages de programmation. Par exemple, les utilisateurs sont en mesure d'ajouter et de supprimer des mots-clés et nous voulons nous assurer de pouvoir les réinitialiser, car par défaut, ces champs ne sont pas réinitialisés.

#### getObject

La fonction `get[form_id]Object()` prend toutes les valeurs des entrées du formulaire en cours puis les attribue à une variable de type objet (*object*). Cet objet suit la hiérarchie comme le schéma pour le formulaire (en fait, son ordre définit l'ordre dans lequel les données seront écrites dans le fichier des données). Il est séparé en deux sections. Tout d'abord, tous les champs obligatoires sont ajoutés à l'objet. Ensuite, la fonction examine chaque champ non obligatoire, vérifiant s'il a une valeur ou non. S'il a une valeur, le champ non obligatoire est ajouté à l'objet. De cette façon, aucune clé avec des valeurs vides ne sera ajoutée aux fichiers de données.

#### addValuesToFields / resetFields

Lorsque l'utilisateur sélectionne une administration ou un projet déjà existant, les données associées à la sélection sont extraites de GitHub. Par la suite *addValuesToFields* remplit certains champs avec les données extraites de GitHub. Si l'utilisateur choisit de rétablir les valeurs par défaut (soit *null*), le *resetField* supprime les valeurs ajoutées automatiquement aux champs provenant des données extraites précédemment. Dans les deux cas (*addValuesToFields* ou *resetField*), ce ne sont pas **tous** les champs du formulaire en cours qui sont automatiquement remplis. Par exemple, dans le formulaire pour les logiciels ouverts, la sélection d'une administration et d'un logiciel existant ne remplissent pas automatiquement les mêmes champs et la réinitialisation d'une sélection ne signifie pas que l'autre sélection est également réinitialisée.
